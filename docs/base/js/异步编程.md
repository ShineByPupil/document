---
outline: [ 2, 3 ]
---

# 异步编程 - JavaScript

## 一、事件循环

> JavaScript 单线程运行时环境的核心调度机制，通过循环检查任务队列，按优先级执行异步任务的回调，实现“非阻塞”并发。

### 1. 工作流程

1. 执行一个宏任务
    - 从宏任务队列中，按优先级选择一个任务执行。
2. 清空微任务队列
    - 依次执行所有微任务，包括执行过程中新产生的微任务（可能导致“微任务递归”）。
3. 执行渲染阶段（可选）
    - 执行 [`requestAnimationFrame`](#_4-requestanimationframe) 回调（在渲染前）
    - 浏览器执行样式计算、布局（Layout）、绘制（Paint）等操作
    - 执行 [`IntersectionObserver`](#_5-intersectionobserver) 等与渲染相关的回调
4. 重复循环
    - 回到步骤 1，处理下一个宏任务，直到所有任务队列为空

### 2. 任务源 (Task Source)

> HTML 标准定义了多种任务源（Task Source），浏览器会为每个任务源维护独立的队列。

| 任务源类型                  | 对应 API/事件                                                      | 优先级示例       |
|------------------------|----------------------------------------------------------------|-------------|
| 用户交互（User Interaction） | `click`、`input`、`keydown`                                      | 最高（即时响应）    |
| 网络请求（Networking）       | `fetch`、`XMLHttpRequest` 回调	                                   | 中（依赖返回速度）   |
| 定时器（Timers）            | `setTimeout`、`setInterval`                                     | 中低（允许延迟）    |
| 渲染任务（Rendering）        | `requestAnimationFrame`                                        | 与渲染帧对齐      | 
| 历史操作（History）          | `history.pushState` 回调                                         | 低           |
| 微任务（Microtask）         | [`Promise`](#三、promise-模式)、`MutationObserver`、`queueMicrotask` | 特殊（非队列，见下文） |

### 3. 事件循环 VS 多线程

| 场景        | 事件循环                 | 多线程              |
|-----------|----------------------|------------------|
| DOM 操作    | ✅ 天然安全，无需同步          | ❌ 需加锁，否则崩溃       |
| I/O 密集型任务 | ✅ 非阻塞，高并发（如处理 1k 请求） | ✅ 线程池可提升吞吐量      |
| CPU 密集型任务 | ❌ 阻塞主线程（如大数据计算）      | ✅ 并行计算利用多核       |
| 开发复杂度     | ✅ 简单，无锁、无竞态          | ❌ 高，需处理线程同步      |
| 调试难度      | ✅ 确定性执行，易追溯          | ❌ 非确定性执行，难复现问题   |
| 内存占用      | ✅ 低（单线程）             | ❌ 高（每线程需独立栈/上下文） |

### 4. requestAnimationFrame

> 浏览器原生提供的动画帧回调调度 API，基于显示器刷新率动态同步执行时机，实现流畅动画渲染。其智能合并帧更新请求，避免无效重绘与布局抖动，确保与屏幕刷新节奏严格同步，提升渲染效率。

### 5. IntersectionObserver

> 浏览器原生提供的异步元素可见性监测 API，通过高效监听目标元素与视口（或指定父容器）的交叉状态变化，智能触发回调。

### 6. requestIdleCallback

> 浏览器原生提供的后台任务调度 API，基于空闲时段（Idle Period）智能分配非关键任务的执行时机，避免阻塞主线程关键渲染与交互流程。

基础用法

```js
const tasks = [];
const idleTask = (deadline) => {
    while (deadline.timeRemaining() > 0 && tasks.length > 0) {
        tasks.pop()();
    }

    if (tasks.length > 0) {
        requestIdleCallback(idleTask);
    }
};

tasks.push(() => console.log('task1'))
const idleTaskId = requestIdleCallback(idleTask);


// 取消空闲任务
// cancelIdleCallback(idleTaskId);
```

## 二、回调函数模式（历史方案）

```js
// 回调地狱示例
getUser(userId, (user) => {
    getOrders(user.id, (orders) => {
        getProducts(orders[0].id, (product) => {
            console.log(product);
        });
    });
});

// 解决方案：解构为命名函数
function handleProduct(product) {
    console.log(product);
}

function handleOrders(user, orders) {
    getProducts(orders[0].id, handleProduct);
}

function handleUser(user) {
    getOrders(user.id, (orders) => handleOrders(user, orders));
}

getUser(userId, handleUser);
```

## 三、Promise

> JavaScript 异步编程的核心抽象模型，以标准化、链式化的方式管理异步操作状态。提供统一的错误处理与流程控制，替代传统回调地狱模式。

#### 基本用法

```js
const promise = new Promise((resolve, reject) => {
    // 异步操作（如 API 请求、定时器等）
    setTimeout(() => {
        const success = true; // 模拟操作是否成功
        if (success) {
            resolve("操作成功！"); // 状态变为 Fulfilled
        } else {
            reject("操作失败！"); // 状态变为 Rejected
        }
    }, 1000);
});

promise
    .then(result => {
        console.log(result); // 输出 "操作成功！"（Fulfilled 状态）
    })
    .catch(error => {
        console.error(error); // 输出 "操作失败！"（Rejected 状态）
    })
    .finally(() => {
        console.log("无论成功与否都会执行");
    });
```

#### API

| 名称                         | 说明                                                      |
|----------------------------|---------------------------------------------------------|
| **实例属性**                   |                                                         |
| **`[[PromiseState]]`**     | 表示 Promise 的当前状态：`"pending"`、`"fulfilled"`、`"rejected"` |
| **`[[PromiseResult]]`**    | 存储 `resolve(value)` 或 `reject(reason)` 传递的值。            |
| **静态方法**                   |                                                         |
| **`Promise.resolve()`**    | 创建一个已解决的 Promise 对象                                     |
| **`Promise.reject()`**     | 创建一个已拒绝的 Promise 对象                                     |
| **`Promise.all()`**        | 等待所有 Promise 完成，全部成功时返回结果数组，有一个失败立即拒绝                   |
| **`Promise.allSettled()`** | 等待所有 Promise 完成（无论成功/失败），返回状态结果数组                       |
| **`Promise.any()`**        | 任意一个 Promise 成功时返回其值，全部失败时拒绝                            |
| **`Promise.race()`**       | 返回第一个完成的 Promise（无论成功/失败）                               |
| **实例方法**                   |                                                         |
| **`then()`**               | 添加解决回调                                                  |
| **`catch()`**              | 添加拒绝回调                                                  |
| **`finally()`**            | 添加最终回调（无论成功/失败都会执行）                                     |

#### 原生代码实现

::: details 详细

```js
class MyPromise {
    constructor(executor) {
        this.state = 'pending';  // 初始状态
        this.value = undefined;  // 成功结果值
        this.reason = undefined; // 失败原因
        this.onFulfilledCallbacks = []; // 成功回调队列
        this.onRejectedCallbacks = [];  // 失败回调队列

        const resolve = (value) => {  // resolve函数
            if (this.state === 'pending') {  // 只有pending状态可转换
                this.state = 'fulfilled';
                this.value = value;
                this.onFulfilledCallbacks.forEach(cb => cb());  // 执行所有成功回调
            }
        };

        const reject = (reason) => {  // reject函数
            if (this.state === 'pending') {
                this.state = 'rejected';
                this.reason = reason;
                this.onRejectedCallbacks.forEach(cb => cb());  // 执行所有失败回调
            }
        };

        try {
            executor(resolve, reject);  // 立即执行executor
        } catch (err) {
            reject(err);  // executor执行出错直接reject
        }
    }

    then(onFulfilled, onRejected) {  // then方法实现链式调用
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;  // 默认值穿透处理
        onRejected = typeof onRejected === 'function' ? onRejected : err => {
            throw err;
        };

        const newPromise = new MyPromise((resolve, reject) => {  // 创建新Promise
            const handleFulfilled = () => {  // 封装成功处理逻辑
                queueMicrotask(() => {  // 微任务异步执行
                    try {
                        const x = onFulfilled(this.value);  // 执行回调获取返回值
                        resolvePromise(newPromise, x, resolve, reject);  // 处理返回值
                    } catch (err) {
                        reject(err);  // 回调执行出错直接reject
                    }
                });
            };

            const handleRejected = () => {  // 封装失败处理逻辑
                queueMicrotask(() => {
                    try {
                        const x = onRejected(this.reason);
                        resolvePromise(newPromise, x, resolve, reject);
                    } catch (err) {
                        reject(err);
                    }
                });
            };

            if (this.state === 'fulfilled') {  // 已成功直接执行
                handleFulfilled();
            } else if (this.state === 'rejected') {  // 已失败直接执行
                handleRejected();
            } else {  // pending状态存入回调队列
                this.onFulfilledCallbacks.push(handleFulfilled);
                this.onRejectedCallbacks.push(handleRejected);
            }
        });

        return newPromise;  // 返回新Promise实现链式调用
    }

    catch(onRejected) {  // catch方法语法糖
        return this.then(undefined, onRejected);
    }

    finally(onFinally) {  // finally方法实现
        return this.then(
            value => MyPromise.resolve(onFinally()).then(() => value),  // 成功时保留原值
            reason => MyPromise.resolve(onFinally()).then(() => {
                throw reason;
            })  // 失败时保留原因
        );
    }

    static resolve(value) {  // 静态resolve方法
        if (value instanceof MyPromise) return value;  // 如果是Promise实例直接返回
        return new MyPromise(resolve => resolve(value));  // 包装成成功状态
    }

    static reject(reason) {  // 静态reject方法
        return new MyPromise((_, reject) => reject(reason));  // 包装成失败状态
    }
}

function resolvePromise(newPromise, x, resolve, reject) {  // 处理Promise解析过程
    if (newPromise === x) {  // 循环引用检测
        reject(new TypeError('Chaining cycle detected'));
        return;
    }

    let called = false;  // 防止多次调用标志
    if ((typeof x === 'object' && x !== null) || typeof x === 'function') {  // 判断是否为对象/函数
        try {
            const then = x.then;  // 获取then方法引用
            if (typeof then === 'function') {  // 判断是否为thenable对象
                then.call(
                    x,
                    y => {  // resolve回调
                        if (called) return;
                        called = true;
                        resolvePromise(newPromise, y, resolve, reject);  // 递归解析
                    },
                    r => {  // reject回调
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                );
            } else {  // 普通对象直接resolve
                resolve(x);
            }
        } catch (err) {  // 获取then时出错
            if (called) return;
            reject(err);
        }
    } else {  // 基础类型值直接resolve
        resolve(x);
    }
}
```

:::

## 四、async/await 模式

> 异步编程语法糖，基于 Promise 构建，以同步风格的代码结构管理异步逻辑。

基础语法

```js
async function loadData() {
    try {
        const user = await fetchUser();
        const orders = await fetchOrders(user.id);
        console.log(orders);
    } catch (error) {
        console.error('加载失败:', error);
    }
}
```

并行优化

```js
async function parallelFetch() {
    const [user, products] = await Promise.all([
        fetchUser(),
        fetchProducts()
    ]);
    console.log(user, products);
}
```

## 五、通信机制

### 1. AJAX

> 是一种基于 XHR 对象的异步通信技术，允许网页在不刷新的情况下向服务器请求数据，并动态更新局部内容，从而提升交互流畅性与用户体验。

#### 基本用法

```js
// 创建 XMLHttpRequest 对象
let xhr = new XMLHttpRequest();

// 初始化请求
xhr.open('GET', 'https://api.example.com/data', true); // true 表示异步

// 设置请求头（可选）
xhr.setRequestHeader('Content-Type', 'application/json');

// 监听请求完成事件
xhr.onload = function () {
    if (xhr.status === 200) {
        // 请求成功
        console.log('Response:', xhr.responseText);
    } else {
        // 请求失败
        console.error('Request failed with status:', xhr.status);
    }
};

// 监听网络错误事件
xhr.onerror = function () {
    console.error('Network error occurred');
};

// 发送请求
xhr.send();
```

#### 设置超时

```js
xhr.timeout = 5000; // 5秒超时

xhr.ontimeout = function () {
    console.error('Request timed out');
};
```

#### 中断请求

```js
// 监听中断事件
xhr.onabort = function () {
    console.log('请求被中止');
};

// 中止请求
setTimeout(() => {
    xhr.abort();
}, 1000); // 1秒后中止请求

```

#### 监控上传进度

```js
let xhr = new XMLHttpRequest();
xhr.open('POST', 'https://api.example.com/upload', true);

// 监控上传进度
xhr.upload.onprogress = function (event) {
    if (event.lengthComputable) {
        const percent = (event.loaded / event.total) * 100;
        console.log(`上传进度: ${ percent.toFixed(2) }%`);
    }
};

xhr.onload = function () {
    if (xhr.status === 200) {
        console.log('上传完成');
    } else {
        console.error('上传失败状态:', xhr.status);
    }
};

// 发送 FormData
let formData = new FormData();
formData.append('file', fileInput.files[0]);
xhr.send(formData);
```

#### API

| 名称                                  | 说明                                                          |
|-------------------------------------|-------------------------------------------------------------|
| **实例属性**                            |                                                             |
| **`readyState`**                    | 请求的状态（0: 未初始化, 1: 已打开, 2: 已发送, 3: 接收中, 4: 完成）               |
| **`status`**                        | HTTP 状态码（如 200 表示成功）                                        |
| **`statusText`**                    | HTTP 状态文本                                                   |
| **`response`**                      | 响应体（根据 `responseType` 可能是字符串、对象、二进制数据等）                     |
| **`responseText`**                  | 响应体作为字符串（仅当 `responseType` 为 `""` 或 `text` 时有效）             |
| **`responseXML`**                   | 响应体作为 XML 文档（仅当 `responseType` 为 `document` 时有效）            |
| **`responseType`**                  | 设置响应类型（如 `""`、`"text"`、`"json"`、`"blob"`、`"arraybuffer"` 等） |
| **`timeout`**                       | 设置请求超时时间（单位：毫秒）                                             |
| **`withCredentials`**               | 是否携带跨域凭证（`true` 或 `false`）                                  |
| **`upload`**                        | 返回 `XMLHttpRequestUpload` 对象，用于监控上传进度                       |
| **实例方法**                            |                                                             |
| **`open(method, url[, async])`**    | 初始化请求（method: 请求方法，url: 请求地址，async: 是否异步）                   |
| **`send([body])`**                  | 发送请求（body: 请求体，如 FormData、Blob、ArrayBuffer 等）               |
| **`abort()`**                       | 中止请求                                                        |
| **`setRequestHeader(name, value)`** | 设置请求头（name: 头字段名，value: 头字段值）                               |
| **`getResponseHeader(name)`**       | 获取指定响应头的值                                                   |
| **`getAllResponseHeaders()`**       | 获取所有响应头（以字符串形式返回）                                           |
| **事件**                              |                                                             |
| **`onreadystatechange`**	           | `readyState` 发生变化时触发                                        |
| **`onload`**                        | 请求完成时触发                                                     |
| **`onerror`**                       | 请求发生错误时触发                                                   |
| **`onabort`**                       | 请求被中断时触发                                                    |
| **`ontimeout`**                     | 请求超时时触发                                                     |
| **`onprogress`**                    | 请求正在接收数据时触发（用于监控下载进度）                                       |
| **`onloadstart`**                   | 请求开始时触发                                                     |
| **`onloadend`**                     | 请求结束时触发（无论成功或失败）                                            |
| **`upload.onprogress`**             | 上传数据时触发（用于监控上传进度）                                           |

#### AJAX 与 Fetch API 的区别

| 特性              | AJAX 独有                                          | Fetch 独有          |
|-----------------|--------------------------------------------------|-------------------|
| **请求状态管理**      | `readyState`、`onreadystatechange`                | ❌                 |
| **上传进度监控**      | `upload.onprogress`                              | ❌                 |
| **XML 数据支持**    | `responseXML`                                    | ❌                 |
| **超时控制**        | 	`timeout`、`ontimeout`                           | ❌                 |
| **请求取消**        | `abort()`                                        | `AbortController` |
| **响应头操作**       | `getResponseHeader()`、`getAllResponseHeaders()`	 | `Headers` 对象      |
| **流式数据处理**      | ❌                                                | `response.body`   |
| **HTTP 错误处理**	  | 需手动检查 `status`                                   | 需检查 `response.ok` |
| **Promise 支持**	 | 需手动封装                                            | 原生支持              |
| **请求配置复用**      | ❌                                                | `Request` 对象      |

### 2. Fetch API

> 现代浏览器提供的原生网络请求接口，基于 Promise 设计，替代传统 XHR 实现更简洁、灵活的异步数据交互。

```ts
interface FetchAPI {
    /**
     * 发起网络请求
     * @param resource 请求资源地址 (字符串、URL 或 Request 对象)
     * @param options 请求配置项
     */
    fetch(resource: RequestInfo | URL, options?: RequestInit): Promise<Response>;
}
```

#### 基本用法

```js
// GET 请求
fetch('https://api.example.com/data')
    .then(response => {
        if (!response.ok) throw new Error('Network error');
        return response.json();
    })
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// POST 请求
fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token'
    },
    body: JSON.stringify({ key: 'value' })
});
```

#### API

**resource 想要获取的资源地址**

| 类型            | 说明              | 示例                                |
|---------------|-----------------|-----------------------------------|
| **`string`**  | 直接使用 URL 字符串    | `'https://api.com/data'`          |
| **`URL`**     | URL 对象          | `new URL('https://api.com/data')` |
| **`Request`** | 预配置的 Request 对象 | `new Request('https://api.com')`  |

**options 自定义设置**

| 属性名                     | 可选值                                                                                                                                                                                                | 说明                                                |
|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| **核心配置**                |                                                                                                                                                                                                    |                                                   |
| **`method`**            | `'GET'`(默认) \| `'POST'` \| `'PUT'` \| `'DELETE'` \| `'PATCH'` \| `'HEAD'` \| `'OPTIONS'` \| `'CONNECT'` \| `'TRACE'`                                                                               | HTTP 请求方法                                         |
| **`headers`**           | `Headers` 对象 \| 普通对象                                                                                                                                                                               | 请求头配置（如 `{ 'Content-Type': 'application/json' }`） |
| **`body`**              | `null`(默认) \| `ReadableStream<Uint8Array>` \| `Blob` \| `BufferSource` \| `FormData` \| `URLSearchParams` \|  `string`                                                                             | 请求体数据（`'GET'`/`'HEAD'` 请求不可用）                     |
| **网络行为**                |                                                                                                                                                                                                    |                                                   |
| **`mode`**              | `'cors'`(默认) \| `'no-cors'` \| `'same-origin'` \| `'navigate'`                                                                                                                                     | 跨域请求模式                                            |
| **`credentials`**       | `'omit'` \| `'same-origin'`(默认) \| `'include'`                                                                                                                                                     | 是否携带 Cookie 和跨域凭证                                 |
| **`cache`**             | `'default'`(默认) \| `'no-store'` \| `'reload'` \| `'no-cache'` \| `'force-cache'` \| `'only-if-cached'`                                                                                             | 缓存策略                                              |
| **`redirect`**          | `'follow'`(默认) \| `'error'` \| `'manual'`                                                                                                                                                          | 是否自动跟随重定向                                         |
| **安全与策略**               |                                                                                                                                                                                                    |                                                   |
| **`referrer`**          | `string`                                                                                                                                                                                           | 指定来源页 URL                                         |
| **`referrerPolicy`**    | `'no-referrer'` \| `'no-referrer-when-downgrade'` \| `'origin'` \| `'origin-when-cross-origin'` \| `same-origin` \| `'strict-origin'` \| `'strict-origin-when-cross-origin'`(默认) \| `'unsafe-url'` | 控制 Referer 头的发送策略                                 |
| **`integrity`**         | `string`（如 `'sha256-abcdef...'`）                                                                                                                                                                   | 子资源完整性校验 (SRI) 的哈希值                               |
| **高级控制**                |                                                                                                                                                                                                    |                                                   |
| **`keepalive`**         | `true` \| `false`(默认)                                                                                                                                                                              | 是否允许请求在页面关闭后继续存活                                  |
| [**`signal`**](#中断请求-1) | `AbortSignal` 对象 \| `null`(默认)                                                                                                                                                                     | 用于中止请求的信号对象（配合 `AbortController` 使用）              |
| **`window`**            | `null`                                                                                                                                                                                             | 通常设置为 `null`（保留字段，浏览器专用                           |
| **实验性功能**               |                                                                                                                                                                                                    |                                                   |
| **`priority`**          | `'auto'`(默认) \| `'high'` \| `'low'`                                                                                                                                                                | 请求优先级                                             |
| **`duplex`**            | `'half'`                                                                                                                                                                                           | 启用流式上传模式                                          |

#### 流式数据处理

> Fetch API 的流式数据处理能力源于其底层的 `ReadableStream` 支持，允许开发者按需分块处理数据


协议层要求:

```http
Transfer-Encoding: chunked
connection: keep-alive
```

代码示例：

```js
fetch('https://api.example.com/stream')
    .then(response => {
        const reader = response.body.getReader(); // 获取流阅读器
        const decoder = new TextDecoder(); // 用于将二进制数据转为文本（比如处理中文）

        // 定义递归读取函数
        function readChunk() {
            return reader.read().then(({ done, value }) => {
                if (done) return; // 流已结束
                console.log('Chunk:', decoder.decode(value));

                readChunk(); // 递归读取下一个数据块
            });
        }

        return readChunk();
    });
```

#### 中断请求

```js
// 创建 AbortController 实例
const abortController = new AbortController();

// 发起 Fetch 请求，并传递 signal 参数
fetch('https://api.example.com/data', {
    signal: abortController.signal // 绑定中断信号
})
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => {
        if (error.name === 'AbortError') {
            console.log('请求已被手动取消');
        } else {
            console.error('请求失败:', error);
        }
    });

// 通过调用 abort() 方法中断请求
abortController.abort();
```

### 3. WebSocket

> 是一种基于独立协议的全双工通信技术，允许客户端与服务器建立持久连接，实现双向实时数据交互。

```js
const ws = new WebSocket('wss://api.example.com/ws');

// 连接成功时
ws.onopen = () => {
    ws.send('连接已建立');
};

// 接收消息
ws.onmessage = (event) => {
    console.log('收到消息:', event.data);
};

// 错误处理
ws.onerror = (error) => {
    console.error('WebSocket错误:', error);
};

// 连接关闭
ws.onclose = () => {
    console.log('连接已关闭');
};

// 发送JSON数据
ws.send(JSON.stringify({ action: 'ping' }));

// 关闭连接
// ws.close();
```

### 4. EventSource

> HTML5 提供的标准化服务端推送技术，基于 HTTP/HTTPS 协议实现单向长连接通信。它通过监听服务器发送的流式事件，以轻量、高效的方式实现实时数据更新。

```js
const eventSource = new EventSource('/api/stream');

// 监听默认消息
eventSource.onmessage = (e) => {
    console.log('实时数据:', e.data);
};

// 监听自定义事件
eventSource.addEventListener('status', (e) => {
    console.log('服务状态:', e.data);
});

// 错误处理（自动重连）
eventSource.onerror = () => {
    console.log('连接中断，尝试重连...');
};
```

### 5. postMessage

> HTML5 提供的跨文档通信 API，允许不同窗口、跨源页面或 Web Workers 间安全传递结构化数据。通过异步消息机制与严格的源验证策略，突破同源策略限制，实现可控的跨域交互。

跨窗口通信：

```js
// 父窗口向iframe发送消息
const iframe = document.querySelector('iframe');
iframe.contentWindow.postMessage('来自父窗口的消息', 'https://child.example.com');

// 接收子窗口消息
window.addEventListener('message', (event) => {
    if (event.origin !== 'https://child.example.com') return;
    console.log('收到子窗口消息:', event.data);
});
```

Worker通信：

```js
// 主线程
const worker = new Worker('worker.js');
worker.postMessage('开始计算');
worker.onmessage = (e) => {
    console.log('计算结果:', e.data);
};

// worker.js
self.onmessage = (e) => {
    const result = heavyCalculation(e.data);
    self.postMessage(result);
};
```

### 6. Beacon API

> 浏览器原生支持的轻量级异步数据上报方案，专为页面卸载阶段（如跳转、关闭）设计，通过非阻塞、低优先级的可靠传输机制，确保关键数据（如日志、埋点）无损提交至服务器。

```js
// 页面关闭前发送数据
window.addEventListener('unload', () => {
    const data = JSON.stringify({ page: 'exit', time: Date.now() });
    navigator.sendBeacon('/api/log', data);
});
```

### 7. RTCPeerConnection

> WebRTC 技术的核心 API，基于标准化协议实现浏览器间点对点（P2P）媒体流传输与实时通信。

```js
// 创建 RTCPeerConnection
const pc = new RTCPeerConnection();

// 创建数据通道
const dc = pc.createDataChannel('chat');
dc.onmessage = (e) => console.log('对方消息:', e.data);
dc.onopen = () => dc.send('Hello Peer!');

// ICE 协商处理
pc.onicecandidate = (e) => {
    if (e.candidate) {
        // 发送 candidate 到对方
    }
};

// 接收远程描述
pc.setRemoteDescription(remoteDescription);
```

### 8. 第三方库

- Axios
    - 解决问题：统一处理复杂 HTTP 请求
    - 使用时机：
        - 需要请求/响应拦截器（如添加全局 Token）
        - 需要取消重复请求
        - 需要自动转换 XML/CSV 等数据格式
- Socket.IO
    - 解决问题：兼容旧浏览器的实时双向通信
    - 使用时机：
        - 需要自动降级到长轮询（支持 IE9+）
        - 需要房间/命名空间隔离
        - 需要心跳检测和自动重连
- MQTT.js
    - 解决问题：物联网设备高效通信
    - 使用时机：
        - 需要发布/订阅模式管理海量设备
        - 需要 QoS 消息质量保证
        - 使用轻量级二进制协议（节省带宽）
- Apollo Client (GraphQL)
    - 解决问题：精确控制数据查询与更新
    - 使用时机：
        - 需要合并多个 REST 请求为单个查询
        - 需要实时数据订阅（如股票行情）
        - 前端定义数据需求结构
- SignalR
    - 解决问题：.NET 生态的实时功能
    - 使用时机：
        - 后端使用 ASP.NET Core
        - 需要与 C# 服务端深度集成
        - 需要自动管理 WebSocket 连接
- PusherJS
    - 解决问题：快速实现实时功能
    - 使用时机：
        - 不想维护 WebSocket 服务器
        - 需要现成的通道管理和调试工具
        - 快速开发原型或中小型应用
