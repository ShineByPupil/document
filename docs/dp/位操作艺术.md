# 位操作艺术

## 位运算基础手册

### 基本位运算符

| 运算符   | 名称    | 功能描述        | 示例         | 二进制结果        |
|-------|-------|-------------|------------|--------------|
| `&`   | 按位与   | 两个位都为1时返回1  | `5 & 3`    | `0b001` (1)  |
| `\|`  | 按位或   | 任意位为1时返回1   | `5 \| 3`   | `0b111` (7)  |
| `^`   | 按位异或  | 位不同时返回1     | `5 ^ 3`    | `0b110` (6)  |
| `~`   | 按位非   | 反转所有位       | `~0b101`   | `-6`         |
| `<<`  | 左移    | 左移指定位数，右侧补0 | `1 << 3`   | `0b1000` (8) |
| `>>`  | 符号右移  | 保留符号位右移     | `-8 >> 1`  | `-4`         |
| `>>>` | 无符号右移 | 右移指定位数，左侧补0 | `-8 >>> 1` | `2147483644` |

### 实用位运算技巧

```js
// 1. 判断奇偶
const isEven = num => (num & 1) === 0;

// 2. 交换两个数
let a = 5, b = 3;
a ^= b;
b ^= a;
a ^= b; // a=3, b=5

// 3. 取绝对值
const abs = n => (n ^ (n >> 31)) - (n >> 31);

// 4. 判断2的幂
const isPowerOfTwo = n => (n & (n - 1)) === 0;

// 5. 快速乘除
const multiplyBy16 = n => n << 4;
const divideBy8 = n => n >> 3;
```

## 位元旗标 (Bitmask Flags)

权限控制实现

```js
class Bitmask {
    constructor(flags = {}) {
        this.FLAGS = flags;
        this.NONE = 0;
    }

    // 添加权限
    add(perm, flag) {
        return perm | flag;
    }

    // 移除权限
    remove(perm, flag) {
        return perm & ~flag;
    }

    // 检查权限
    has(perm, flag) {
        return (perm & flag) === flag;
    }
}

// 权限定义
const PERM = {
    READ: 1 << 0,   // 0b0001
    WRITE: 1 << 1,  // 0b0010
    DELETE: 1 << 2  // 0b0100
};

// 使用示例
const mask = new Bitmask(PERM);
let userPerm = PERM.READ | PERM.WRITE; // 0b0011
console.log(mask.has(userPerm, PERM.DELETE)); // false
```

状态组合示意图

```aiignore
用户权限: 0b101 (READ + DELETE)
权限检查: 
   READ: 0b101 & 0b001 = 0b001 ✔️
  WRITE: 0b101 & 0b010 = 0b000 ❌
```

## 位压缩存储

数据压缩方案

```js
// RGB颜色压缩（24位）
function packRGB(r, g, b) {
    return (r << 16) | (g << 8) | b;
}

// 日期压缩（年16位/月4位/日5位）
const packDate = (y, m, d) => (y << 9) | (m << 5) | d;
```

内存优化对比

| 数据类型    | 常规存储    | 位压缩存储   | 节省比  |
|---------|---------|---------|------|
| RGB颜色   | 3 bytes | 4 bytes | -33% |  
| 日期（年月日） | 8 bytes | 4 bytes | 50%  |

## 大型复杂应用案例

### 位图索引

```js
class BitmapIndex {
    constructor() {
        this.index = new Map();  // value -> bitmask
        this.counter = 0;
    }

    add(value) {
        if (!this.index.has(value)) {
            this.index.set(value, 1 << this.counter++);
        }
        return this.index.get(value);
    }
}

// 使用示例
const index = new BitmapIndex();
const colors = ['red', 'green'].map(c => index.add(c));
```

### 布隆过滤器

```js
class BloomFilter {
    constructor(size = 1024) {
        this.bits = new Uint32Array(Math.ceil(size / 32));
    }

    add(str) {
        const hash = this._hash(str);
        this.bits[Math.floor(hash / 32)] |= 1 << (hash % 32);
    }
}
```

### 协议解析

```js
class ProtocolParser {
    static parse(header) {
        return {
            version: (header >>> 28) & 0xF,
            type: (header >>> 24) & 0xF,
            data: header & 0xFFFFFF
        };
    }
}
```
